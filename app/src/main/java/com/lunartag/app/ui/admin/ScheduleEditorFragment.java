package com.lunartag.app.ui.admin;

import android.app.AlertDialog;
import android.app.TimePickerDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.text.InputType;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TimePicker;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;

import com.lunartag.app.databinding.FragmentScheduleEditorBinding;

import org.json.JSONArray;
import org.json.JSONException;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;

public class ScheduleEditorFragment extends Fragment {

    // These MUST match the keys used in CameraFragment to ensure they share data
    private static final String PREFS_SCHEDULE = "LunarTagSchedule";
    private static final String KEY_TIMESTAMP_LIST = "timestamp_list";
    
    // Keys for checking if the feature is enabled (to hide/show UI)
    private static final String PREFS_TOGGLES = "LunarTagFeatureToggles";
    private static final String KEY_ADMIN_ENABLED = "customTimestampEnabled";

    private FragmentScheduleEditorBinding binding;
    private ScheduleAdapter adapter;
    private List<Long> timestampList;

    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        binding = FragmentScheduleEditorBinding.inflate(inflater, container, false);
        return binding.getRoot();
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        // Check if Admin Mode is actually enabled via Remote Config
        SharedPreferences featurePrefs = requireContext().getSharedPreferences(PREFS_TOGGLES, Context.MODE_PRIVATE);
        boolean isFeatureEnabled = featurePrefs.getBoolean(KEY_ADMIN_ENABLED, false);

        if (!isFeatureEnabled) {
            // If disabled, hide everything and stop.
            binding.getRoot().setVisibility(View.GONE);
            return;
        }
        
        binding.getRoot().setVisibility(View.VISIBLE);

        // Load existing timestamps from storage
        timestampList = loadTimestamps();

        // Setup RecyclerView
        adapter = new ScheduleAdapter(timestampList, new ScheduleAdapter.OnTimestampDeleteListener() {
            @Override
            public void onTimestampDeleted(int position) {
                timestampList.remove(position);
                adapter.notifyItemRemoved(position);
                saveTimestamps(timestampList); // Save changes immediately
                updateCountUI();
            }
        });

        // FIX: Use the correct ID 'recyclerViewTimestamps' from your XML
        binding.recyclerViewTimestamps.setLayoutManager(new LinearLayoutManager(getContext()));
        binding.recyclerViewTimestamps.setAdapter(adapter);

        updateCountUI();
        setupClickListeners();
    }

    private void setupClickListeners() {
        // 1. Manual Add Button
        binding.buttonAddTimestamp.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showTimePickerAndAdd();
            }
        });

        // 2. Auto-Generate Button
        binding.buttonAutoGenerate.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showAutoGenerateDialog();
            }
        });
    }

    private void updateCountUI() {
        if (binding == null) return;
        
        int count = timestampList.size();
        
        // Update the 'Slots remaining' text
        binding.textSlotsRemaining.setText("Slots available: " + count);

        // Toggle the 'No timestamps' empty state text
        if (count == 0) {
            binding.textNoTimestamps.setVisibility(View.VISIBLE);
            binding.recyclerViewTimestamps.setVisibility(View.GONE);
        } else {
            binding.textNoTimestamps.setVisibility(View.GONE);
            binding.recyclerViewTimestamps.setVisibility(View.VISIBLE);
        }
    }

    // --- Logic: Add Single Timestamp ---

    private void showTimePickerAndAdd() {
        Calendar cal = Calendar.getInstance();
        int hour = cal.get(Calendar.HOUR_OF_DAY);
        int minute = cal.get(Calendar.MINUTE);

        TimePickerDialog picker = new TimePickerDialog(getContext(), new TimePickerDialog.OnTimeSetListener() {
            @Override
            public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
                Calendar selectedTime = Calendar.getInstance();
                selectedTime.set(Calendar.HOUR_OF_DAY, hourOfDay);
                selectedTime.set(Calendar.MINUTE, minute);
                selectedTime.set(Calendar.SECOND, 0);
                selectedTime.set(Calendar.MILLISECOND, 0);
                
                // --- LOGIC FIX: Handle Midnight Crossing for Manual Entry ---
                // If the list is not empty, check the last entry.
                if (!timestampList.isEmpty()) {
                    // Get the latest timestamp currently in the list
                    long lastTimestamp = timestampList.get(timestampList.size() - 1);
                    
                    // If the new time (e.g., 00:30) is numerically smaller than the last one (e.g., 23:30),
                    // it means the user intends this for the NEXT day.
                    // Note: This logic assumes the user enters time sequentially.
                    if (selectedTime.getTimeInMillis() < lastTimestamp) {
                        selectedTime.add(Calendar.DAY_OF_MONTH, 1);
                        Toast.makeText(getContext(), "Added to Next Day", Toast.LENGTH_SHORT).show();
                    }
                }
                
                addTimestamp(selectedTime.getTimeInMillis());
            }
        }, hour, minute, false);
        picker.show();
    }

    private void addTimestamp(long timestamp) {
        timestampList.add(timestamp);
        Collections.sort(timestampList); // Keep them in chronological order
        adapter.notifyDataSetChanged();
        saveTimestamps(timestampList);
        updateCountUI();
    }

    // --- Logic: Auto-Generate Schedule ---

    private void showAutoGenerateDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
        builder.setTitle("Auto-Generate Schedule");
        builder.setMessage("Enter Interval (Minutes).\nGenerates full day schedule.");

        // Set up the input logic
        final EditText inputInterval = new EditText(getContext());
        inputInterval.setInputType(InputType.TYPE_CLASS_NUMBER);
        inputInterval.setHint("Interval (Default: 30)");
        
        LinearLayout container = new LinearLayout(getContext());
        container.setOrientation(LinearLayout.VERTICAL);
        container.setPadding(50, 20, 50, 20);
        container.addView(inputInterval);
        
        builder.setView(container);

        builder.setPositiveButton("Generate", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                String intervalStr = inputInterval.getText().toString();
                int interval = 30; // Default changed to 30 for wider spread
                if (!intervalStr.isEmpty()) {
                    try {
                        interval = Integer.parseInt(intervalStr);
                    } catch (NumberFormatException e) {
                        // keep default
                    }
                }
                
                // FIXED: Logic changed from fixed 8-5 to a more flexible range or 24h.
                // For simplicity in this request, we generate a standard "Day Shift" + "Night Shift" capability.
                // Let's generate from 8 AM to 11 PM by default as a safe wide range,
                // or you can customize parameters here.
                // To support the "12 AM to 12 PM" request, we simply ensure the loop handles dates correctly.
                
                // Example: 8 AM to 8 AM (Next Day) - Full 24h Cycle
                generateSchedule(8, 0, 8, 0, interval);
            }
        });

        builder.setNegativeButton("Cancel", null);
        builder.setNeutralButton("Clear All", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                timestampList.clear();
                adapter.notifyDataSetChanged();
                saveTimestamps(timestampList);
                updateCountUI();
                Toast.makeText(getContext(), "Schedule Cleared", Toast.LENGTH_SHORT).show();
            }
        });

        builder.show();
    }

    /**
     * Updated Generator: Handles Midnight Crossing.
     * If endHour < startHour, it assumes 'endHour' is on the next day.
     */
    private void generateSchedule(int startHour, int startMin, int endHour, int endMin, int intervalMinutes) {
        timestampList.clear();
        
        Calendar current = Calendar.getInstance();
        current.set(Calendar.HOUR_OF_DAY, startHour);
        current.set(Calendar.MINUTE, startMin);
        current.set(Calendar.SECOND, 0);
        current.set(Calendar.MILLISECOND, 0);

        Calendar end = Calendar.getInstance();
        end.set(Calendar.HOUR_OF_DAY, endHour);
        end.set(Calendar.MINUTE, endMin);
        end.set(Calendar.SECOND, 0);
        end.set(Calendar.MILLISECOND, 0);

        // --- LOGIC FIX: Detect Night Shift (Midnight Crossing) ---
        // Example: Start 22:00, End 03:00.
        // Initially 'end' (03:00 Today) is BEFORE 'current' (22:00 Today).
        // We must add 1 day to 'end'.
        if (end.before(current)) {
            end.add(Calendar.DAY_OF_MONTH, 1);
        }
        
        // If start == end, assume full 24h cycle
        if (end.equals(current)) {
            end.add(Calendar.DAY_OF_MONTH, 1);
        }

        // Generate loop
        while (current.before(end) || current.equals(end)) {
            timestampList.add(current.getTimeInMillis());
            current.add(Calendar.MINUTE, intervalMinutes);
        }

        Collections.sort(timestampList);
        adapter.notifyDataSetChanged();
        saveTimestamps(timestampList);
        updateCountUI();
        Toast.makeText(getContext(), "Generated " + timestampList.size() + " slots.", Toast.LENGTH_SHORT).show();
    }

    // --- Storage Helpers ---

    private void saveTimestamps(List<Long> list) {
        SharedPreferences prefs = requireContext().getSharedPreferences(PREFS_SCHEDULE, Context.MODE_PRIVATE);
        JSONArray jsonArray = new JSONArray();
        for (Long ts : list) {
            jsonArray.put(ts);
        }
        prefs.edit().putString(KEY_TIMESTAMP_LIST, jsonArray.toString()).apply();
    }

    private List<Long> loadTimestamps() {
        List<Long> list = new ArrayList<>();
        SharedPreferences prefs = requireContext().getSharedPreferences(PREFS_SCHEDULE, Context.MODE_PRIVATE);
        String json = prefs.getString(KEY_TIMESTAMP_LIST, "[]");
        try {
            JSONArray jsonArray = new JSONArray(json);
            for (int i = 0; i < jsonArray.length(); i++) {
                list.add(jsonArray.getLong(i));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
        Collections.sort(list);
        return list;
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        binding = null;
    }
}